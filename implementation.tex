\section{Implementation of Lind}
\label{sec.implementation}

To test our \lip design, we used it to implement a secure virtual machine
called Lind\footnote{\scriptsize Lind is an Old English word for a shield
constructed from two layers of linden wood.}.  Lind is divided into a
\emph{computational module} that enforces software fault isolation (SFI) and a
library OS that safely reimplements OS functionality needed by user
applications.  We use a slightly modified version of Native Client
(NaCl)~\cite{NaCl-09} for the computational module; the library OS is
implemented using Restricted Python (Repy)~\cite{Repy-10}. Finally, to support
complex user applications without exposing potentially unsafe kernel paths, we
provide a safe POSIX implementation, built on top of Repy.

In this section we provide a brief description of these components and how they
were integrated into Lind, followed by an example of how the system works.

\subsection{Primary Components}

\paragraph{Native Client.}
We use NaCl to isolate the computation of the user application
from the kernel. NaCl allows Lind to work on most types of legacy code.
It compiles the programs to produce a binary with software fault isolation.
This prevents applications from performing system calls
or executing arbitrary instructions.
Instead, the application will call into a small, privileged
part of NaCl that forwards system calls. In NaCl's original implementation,
these calls are usually forwarded to the host OS kernel. To build Lind, we
modified NaCl to instead forward these calls to our library OS, SafePOSIX
(described in detail below).

\brendan{We don't seem to actually say more than about one sentence about
SafePOSIX below before launching into the example. Maybe we should fix that?}

\paragraph{Seattle's Repy.}

To build an API to access the safe parts of the underlying kernel while
supporting existing applications, we need two things. First, we need a
restricted sandbox that only allows access to commonly used kernel paths. We
used Seattle's Repy~\cite{Repy-10} sandbox to perform this task. Second, we
implemented the widely accepted standard POSIX interface on top of Repy to
provide complex system functions to user programs.

Because the sandbox kernel is the only code in direct contact with the host
system calls, it should be small (to make it easy to audit) while providing
primitives that can be used to build more complex functionality.
We used Seattle's Repy system API due to its tiny (around 8K LOC) sandbox
kernel , and its minimal set of system call APIs needed to build general
computational functionality. Repy allows access only to the popular portions of
the OS kernel through 33 basic API functions, including 13 network functions, 6
file functions, 6 threading functions, and 8 miscellaneous functions (Table
\ref{table:RepyKernel})~\cite{Repy-10, RepyKernel}.

\begin{table}
\centering
\caption {Repy sandbox kernel functions that support Lind's SafePOSIX re-creation.}

  \begin{tabular}{ | p{2.5cm} | p{4.5cm} |}
  \hline
  \textbf{Repy Function} & \textbf{Available System Calls}  \\ \hline

Networking & \emph{gethostbyname, openconnection, getmyip, socket.send, socket.receive, socket.close,
listenforconnection, tcpserversocket.getconnection, tcpserversocket.close, sendmessage, listenformessage,
udpserversocket.getmessage, and udpserversocket.close.} \\ \hline

I/O Operations & \emph{openfile, file.close, file.readat, file.writeat, listfiles, and removefile.} \\ \hline

Threading & \emph{createlock, sleep, lock.acquire, lock.release, createthread, and getthreadname.} \\ \hline

Miscellaneous Functions & \emph{getruntime, randombytes, log, exitall, createvirtualnamespace,
virtualnamespace.evaluate, getresources, and getlasterror.}  \\ \hline
    \end{tabular}
    \label{table:RepyKernel}
\end{table}


\subsection{Enhanced Safety in Call Handling with SafePOSIX Re-creation}

The full kernel interface is extremely rich and hard to protect.
The dual sandbox Lock-in-Pop design used to build Lind provides enhanced
safety protection through both isolation and a POSIX interface that
reimplements risky system calls to
provide full-featured API for legacy applications, with minimal impact on the kernel.

\textbf{An example of system call execution.}
In Lind, a system call issued from user code is
received by NaCl, and then redirected to our system API module, which
includes a POSIX API. This set of standard
operating system interfaces provides
necessary operating functionalities. A standard POSIX API is large and complex,
making it difficult to ensure its implementation is secure and bug-free.
Lind takes advantage of the fact that Repy is a programming language sandbox to
construct a variation on the POSIX API. Following the
Lock-in-Pop design, to service a system call in NaCl, a server routine in
Lind marshals its arguments into a text string, and sends the call and the arguments
to the Repy sandbox. The re-created system call marshals the result and
returns it back to NaCl. Eventually, the result is returned as the appropriate
native type to the calling program.

The file system API in \lip needs only
to provide functionality of writing data to storage.
%\yanyan{why only discuss file system?
%how about network, threading, etc?}
%\yiwen{threading is done by the OS kernel directly, no reconstruction to discuss.
%And our network functions are really simple, things like opening and closing a socket is
%not very exciting.}
It eliminates the need of having a direct abstraction, the
concept of file permissions, links, or even the concept of multiple files.
The system API safe re-creation is a set of more complicated system calls
derived from functions in the sandbox kernel.
It serves as a mediator between the user code
and the OS kernel. The re-creation is safe
because the reconstructed calls are isolated in a sandbox, and its code is written 
in a memory-safe programming language.

Here is an example of how this re-creation would work with the symbolic link function. 
Instead of relying on the underlying kernel to create symbolic links between real files 
in the host file system, Lind builds and maintains its own metadata to represent a virtual symbolic link 
between files within Lind's file system. In this case, if there is a bug in this symbolic link function, 
such as creation of a link with a deleted file, the bug will be contained within Lind's re-creation. \cappos{Be specific here about what part of the system
you are referring to!}
As a result, instead of creating a security issue, the application is denied privileged access
to the host OS kernel. 
Therefore, attackers will not be able to leverage a bug within the symbolic link function to 
exploit the host kernel.  


\cappos{I find the bridge text here odd.  We should perhaps summarize instead
of looking forward so much...}
The Lind design offers a promising new approach to OS kernel code protection. 
To determine if the ideas behind Lind were valid, we 
designed a multi-step study to compare its security performance against a number 
of existing virtualization systems. Details of the study and its results are presented 
in the following section.
